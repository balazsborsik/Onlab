\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{t1enc}
\usepackage[magyar]{babel}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{minted} 
\usepackage{enumitem}
\usepackage{bm}
 \geometry{ a4paper, textwidth=180mm, textheight=257mm, left=15mm, top=20mm, bottom=25mm}
\usepackage{fancyhdr}
\pagestyle{fancy}

\chead{\includegraphics[height=15mm]{bme_logo_kicsi}}
\setlength{\headsep}{50pt}
\geometry{bottom=30mm}
\fancyfoot[C]{\footnotesize\sl
\begin{tabular}{r|l} 
Budapesti Műszaki és Gazdaságtudományi Egyetem & 1117 Budapest, Magyar tudósok körútja 2. I.B.132.\\
Villamosmérnöki és Informatikai Kar & Telefon: 463-2585, Fax: 463-3157\\
Számítástudományi és Információelméleti Tanszék & http:\textbackslash\textbackslash www.cs.bme.hu\\
\end{tabular}}
\renewcommand{\headrulewidth}{0.4pt}\renewcommand{\footrulewidth}{0.4pt}

\begin{document} \ \
\vspace{2mm}
\begin{center}
{\Large\sc
Önálló Labor\\[5mm]
\bf 
Random konstrukciók programozása a Zarankiewicz problémához
\\[10mm]
{\Large
Borsik Balázs
}\\[10mm]
Témavezető: Dr.Héger Tamás
}
\end{center}
\vspace{1cm}

\section*{1. Alapfogalmak}
\begin{itemize}
    \item \bm{$K_{n,m}$}: Egy $(N,M,E)$ teljes páros gráf, ahol $|N|=n$, $|M|=m$ és bármely $u \in N$ és $v \in M$ között van él behúzva.
    \item \bm{$C_4$}: $K_{2,2}$
    \item \textbf{Páros gráf mátrixos ábrázolása}: A dokumentumban a \emph{gráf} kifejezés mindig páros gráfokra utal, még abban az esetben is, ha ez nincs külön kihangsúlyozva. Egy $(N, M, E)$ páros gráfhoz gyakran hozzárendeljük a hozzá tartozó szomszédsági mátrixot, melynek mérete $|N| \times |M|$. Ebben a megfeleltetésben a mátrix $n$-edik sora egy $N$-beli csúcsot, az $m$-edik oszlopa pedig egy $M$-beli csúcsot reprezentál. A két csúcs között akkor van él, ha a szomszédsági mátrix $(n,m)$ pozíciójában $1$ található; ha pedig $0$, akkor nincs él a két csúcs között.
    \item \textbf{Zarankiewicz-szám:} Egy $G = (A,B;E)$ páros gráf $K_{s,t}$-mentes, ha nem tartalmaz olyan $s$ csúcsot $A$-ban és $t$ csúcsot $B$-ben, amelyek egy $K_{s,t}$-vel izomorf részgráfot alkotnak. Az $(m,n)$ méretű $K_{s,t}$-mentes páros gráf éleinek maximális számát $Z_{s,t}(m,n)$-nel jelöljük, és Zarankiewicz-számnak nevezzük. A dokumentumban amennyiben $s,t$ nincs jelölve, akkor $Z(m,n)$ ekvivalens $Z_{s,t}(m,n)$-nel.
    \item \textbf{Zarankiewicz-probléma (eredeti megfogalmazás):} Vegyünk egy $n \times m$-es mátrixot, amely csak 0 és 1 értékeket tartalmaz. Legkevesebb hány darab 1-es szükséges, hogy mindenképp tartalmazzon $s \times t$-es csupa 1-es részmátrixot? Ez a definíció megegyezik $Z_{s,t}(m,n) + 1$ -el (ez a fent bemutatott mátrixos áttérés után rögtön látszik).
    \item Egy $C_4$ mentes gráf \textbf{triviálisan kiegészíthető}, ha létezik olyan még nem behúzott él, melynek behúzása után nem keletkezik $C_4$.
\end{itemize}

\section*{2. Bemutatás}
Mint látható, a Zarankiewicz probléma egy extremális gráfelméleti probléma. A problémára több képlet is ad értelmezhető felső becsléseket, de ezek a becslések általában a paraméterek nagyságának vagy aszimmetriájának növelésével jelentősen eltérhetnek a pontos értékektől.\\

Alsó becslésekre kevesebb képlet található; ezekben az esetekben különféle konstrukciók (pl. projektív síkok, affin síkok), vagy kimerítő keresések adhatnak jobb közelítő értéket.\\

Az önálló labor célja a random konstrukciókkal kapott alsó becslések vizsgálata és programozása volt. A kipróbált módszerek többsége már ismert módszerek különböző heurisztikák alapján történő módosításainak eredménye.

\section*{3. Matematikai háttér}

\begin{itemize}
    \item Egy \textbf{incidenciastruktúra} egy $(\mathcal{P}, \mathcal{L}, I)$ hármas, ahol:
    \begin{itemize}[nosep]
      \item $\mathcal{P}$ egy halmaz, elemei a \emph{pontok},
      \item $L$ egy $P$-től különböző halmaz, elemei az \emph{egyenesek} (vagy blokkok),
      \item $I \subseteq P \times L$ az \emph{incidenciareláció}, vagyis azon pont–egyenes párok halmaza, melyek „kapcsolatban állnak egymással”.
    \end{itemize}
    Minden incidenciastruktúra megfeleltethető egy $G = (A, B, E)$ páros gráfnak, ahol $A = P$, $B = L$, és $a \in A$, $l \in L$ között akkor van él, ha $(a, l) \in I$.
    \item A \textbf{projektív sík} egy incidenciastruktúra $(\mathcal{P}, \mathcal{L}, I)$, ahol:
    \begin{itemize}[nosep]
      \item $\mathcal{P}$ a \emph{pontok} halmaza,
      \item $\mathcal{L}$ az \emph{egyenesek} (vagy blokkok) halmaza,
      \item $I \subseteq \mathcal{P} \times \mathcal{L}$ az \emph{incidenciareláció},
    \end{itemize}
    amely az alábbi tulajdonságokkal rendelkezik:
    \begin{itemize}[nosep]
      \item Bármely két különböző pontra pontosan egy olyan egyenes létezik, amely mindkettővel incidens.
      \item Bármely két különböző egyenesre pontosan egy olyan pont létezik, amely mindkettővel incidens.
      \item Létezik négy pont, amelyek közül semelyik hármat nem tartalmazza ugyanaz az egyenes (vagyis nincs olyan egyenes, amely háromnál több közülük levő ponttal incidens lenne).
    \end{itemize}
    
    A definícióból következik, hogy bármely egyeneshez ugyanannyi pont tartozik, mint ahány egyenes incidens egy adott ponttal. Ezt a közös számot $q+1$-nek jelöljük, ahol $q$ a sík \emph{rendje}.
    \item \bm{$t-(v,K,\lambda)$} \textbf{design:} Legyen $\emptyset \neq K \subset \mathbb{Z}^+$. Egy $(P, B)$ incidenciastruktúrát \emph{$t-(v, K, \lambda)$ designnak} nevezünk, ha:
    \begin{itemize}[nosep]
      \item $|P| = v$,
      \item minden $B \in B$ esetén $|B| \in K$,
      \item minden $t$ különböző pont pontosan $\lambda$ közös blokkban szerepel.
    \end{itemize}
    Ha $K = \{k\}$, akkor egyszerűen $t-(v, k, \lambda)$ designról beszélünk.
    Ilyen design esetén:
    \[
    b = |B| = \lambda \binom{v}{t} \bigg/ \binom{k}{t}, \quad
    r = \frac{bk}{v} = \lambda \binom{v-1}{t-1} \bigg/ \binom{k-1}{t-1}
    \]
    ahol $b$ a blokkok száma, $r$ pedig az egy pontra eső blokkok száma. Feltételezzük, hogy $k < v$ és $\lambda \geq 1$.
    
    A $t$--$(v, k, \lambda)$ design incidenciagrafja $K_{t, \lambda+1}$-mentes, és ezek tartalmazzák a legtöbb élt az ilyen típusú gráfok közül.
    
    A $(t, v, k, \lambda)$ paramétereket akkor nevezzük \emph{megengedettnek} (vagy admisszibilisnek), ha pozitív egészek, teljesül:
    \[
    2 \leq t \leq k < v, \quad
    b = \lambda \binom{v}{t} \bigg/ \binom{k}{t} \in \mathbb{Z}, \quad
    r = \lambda \binom{v-1}{t-1} \bigg/ \binom{k-1}{t-1} \in \mathbb{Z}
    \]
    
    Például egy $q$ rendű projektív sík egy $2-(q^2 + q + 1, q + 1, 1)$ design.
    \\[5mm]
    \noindent Forrás: \textit{Damásdi, G., Héger, T. and Szőnyi, T., 2013. The Zarankiewicz problem, cages and geometries.}
\end{itemize}

\section*{4. Felső becslések bemutatása}
A felső becslésekhez alkalmazható például a \textbf{Jensen-egyenlőtlenség}, amely az alábbi módon fogalmazható meg:

\[
\phi\left( \frac{1}{n} \sum_{i=1}^{n} x_i \right) \leq \frac{1}{n} \sum_{i=1}^{n} \phi(x_i),
\]

ha $\phi$ konvex függvény. Ez az egyenlőtlenség segít az egyes Zarankiewicz-számokra adott becslések levezetésében.
\\[2mm]
A projekt során is használt felső becslés pedig \textbf{Roman becslése} volt, ami a Jensen-egyenlőtlenségből kapott paraméterezett változatt, így sokkal kényelmesebben használható. A program során ez a becslés adta az élvalószínűségek alapját.
\\[2mm]
\textbf{Roman-egyenlőtlenség:} Legyen $I \subset \mathbb{R}$ egy intervallum, $f : I \to \mathbb{R}$ egy szigorúan növekvő konvex vagy szigorúan csökkenő konkáv függvény, $n \in \mathbb{N}$, $x_1, \dots, x_n, p, p+1 \in I \cap \mathbb{Z}$. Ekkor
\[
\sum_{i=1}^{n} x_i \leq \frac{\sum_{i=1}^{n} f(x_i)}{f(p+1) - f(p)} + n \cdot \frac{p f(p+1) - (p+1) f(p)}{f(p+1) - f(p)}.
\]
\\[2mm]
Az egyenlőség pontosan akkor áll fenn, ha $x_i \in \{p, p+1\}$ minden $1 \leq i \leq n$ esetén, vagy ha $\{x_1, \dots, x_n, p, p+1\} \subset I'$ egy olyan intervallumban, amelyen $f$ lineáris.
\\[2mm]
\textbf{Bizonyítás:} Legyen $a, c \in \mathbb{R}$, ahol $a > 0$, továbbá legyen $F(x) = a f(x) - x + c$

Válasszuk meg $a$ és $c$ értékét úgy, hogy teljesüljön:
\[
F(p) = a f(p) - p + c = 0,\quad F(p+1) = a f(p+1) - (p+1) + c = 0.
\]
Ebből következik:
\[
a = \frac{1}{f(p+1) - f(p)},\quad c = \frac{p f(p+1) - (p+1) f(p)}{f(p+1) - f(p)}.
\]

Mivel $f$ növő és konvex, ezért $a > 0$, így $F(x)$ is konvex.

Két eset lehetséges:
\begin{itemize}
  \item Vagy $F(x) = 0$ egy $[p, p+1]$ intervallumot tartalmazó intervallumon, vagy
  \item $F(x) = 0$ csak a $p$ és $p+1$ egész számokra teljesül.
\end{itemize}
Mindkét esetben $F(x) \geq 0$ minden egész $x$-re.

Ezért:
\[
0 \leq \sum_{i=1}^n F(x_i) = \sum_{i=1}^n (a f(x_i) - x_i + c) = a \sum_{i=1}^n f(x_i) - \sum_{i=1}^n x_i + n c,
\]
amiből:
\[
\sum_{i=1}^n x_i \leq a \sum_{i=1}^n f(x_i) + n c.
\]

Az $a$ és $c$ behelyettesítésével megkapjuk az állított egyenlőtlenséget. Az egyenlőség pontosan akkor teljesül, ha minden $i$-re $F(x_i) = 0$, vagyis az ismertetett két eset valamelyike áll fenn.\\[2mm]
\textbf{Roman-féle felső korlát:} Legyen $G = (A, B; E)$ egy $K_{s,t}$-mentes páros gráf, ahol $|A| = m$, $|B| = n$, és $p \geq s - 1$. Ekkor $G$ éleinek számára teljesül:
\[
e(G) \leq \frac{t - 1}{\binom{p}{s - 1}} \binom{m}{s} + n \cdot \frac{(p + 1)(s - 1)}{s}.
\]

\section*{Programváltozatok}

\textbf{Program alapja:} A program minden változata \texttt{C++} nyelven készült. A gráfokat szomszédsági mátrixban tároljuk, mivel a vizsgált intervallumban a használt algoritmusokkal ez a módszer gyorsabbnak bizonyult az éllistás tárolásnál.
\\[2mm]
\noindent \textbf{Eredmények táblázat jelölései:} Az eredmény táblázatban pár különböző méretű, n,m máretű Z(n,m) szolgál a módszer bemutatására. Továbbá még kettő mérőszám mindkét márőszám csak a Z(10,10) től Z(40,40)-ig tartó eredményekből dolgozik, hogy a módszereket ne torzítsák a 10,10 alatti könnyen megtalálható esetek. Az \emph{Él \%} a legjobb általunk talált eredményekkel veti össze az intervallumon a módszert, úgy, hogy összeadja az intervallumon belül talált legjobb gráfok éleit és az így kapott élszámot leosztja, a legjobb eredmények összélszámával. A \emph{Diff} azt mutatja meg, hogy hányszor adott a módszer teljesen/egy híján/két híján pontos értékeket, az alábbi formátumban : <pontos> <pontos -1> < pontos - 2>. (A 10-40 intervallumban összesen 496 vizsgált eset van)

\subsection*{1. Mohó algoritmus}
\textbf{Algoritmus:} Véletlen sorrendben végig megyünk az összes élen, ha egy él behúzása $C_4$-et hozna létre, akkor nem húzzuk be, különben behúzzuk. (Így a kapott gráf biztos, hogy triviálisan nem kiegészíthető, hiszen, ha az lenne, akkor a behúzható élt már behúztuk volna, amikor az algoritmus során vizsgáljuk.)

\textbf{Motiváció:} Az éleket csak sorban vizsgálva a gráf nagyon aszimmetrikus lenne, például az elsőnek vizsgált csúcs össze lenne kötve az egész másik csúcsosztállyal, és mivel a felső becslések is minél egyenletesebb fokszámeloszlást vesznek alapul, a projektív síkok, és abból képzett konstrukciók is ilyenek, ezért az élek random sorrendje lehetővé teszi egy kiegyensúlyozottabb gráf előállítását, miközben a gráf továbbra is triviálisan nem kiegészíthető marad.

\textbf{Eredmények:}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Z(n, m)} & \textbf{Mohó algoritmus} \\
\hline
$Z(9,30)$  & 63 \\
$Z(14, 29)$ & 85 \\
$Z(20, 20)$ & 88 \\
$Z(20, 37)$ & 130 \\
$Z(30, 30)$ & 150 \\
$Z(40, 40)$ & 222 \\
\hline
Él \% & 92.88\% \\
\hline
Diff & 69 46 33 \\
\hline
Futásidő & 1843s \\
Iteráció & 18000 \\
\hline
\end{tabular}
\end{table}

\subsection*{2. Moser-Tardos}

\textbf{Algoritmus:} Végig megyünk az éleken, és minden élt az LLL-ből kiszámolt valószínűséggel behúzunk, közben számon tartjuk a kisebbik/nagyobbik (még nem eldöntött, meg kell nézni mindkettőt!) csúcsosztályban az összes csúcspár közös szomszédjainak számát. Ha egy $(u,v)$ él behúzásra kerül, akkor az összes olyan $(u,u')$ csúcspár közös szomszédjainak számát növeljük eggyel, ahol $u'$ szomszédos $v$-vel. Ezután végigmegyünk minden csúcspáron, és ha a közös szomszédaik száma $\geq 2$, akkor újrasorsoljuk a csúcspár összes élét. Ezt addig ismételgetjük, amíg van olyan csúcspár, ahol a közös szomszédok száma $\geq 2$. (Triviális javítás a mohó algoritmus használata a folyamat vége után, ennek eredményeiről lentebb.)

\textbf{Motiváció:} A Moser-Tardos módszer jól ráillik a problémára és az újrasorsolások által pont két csúcs közös szomszédjait javítja ki, és ahol a gráf már $C_4$-mentes, azt kevésbé változtatja meg. Ezért ez a célzott javítgatás jobb eredményekre ad reményt.

\textbf{Eredmények:}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{Z(n, m)} & \textbf{Nagyobb} & \textbf{Nagyobb + mohó} & \textbf{Kisebb + mohó} & \textbf{Nagyobb + LLL TODO} \\
\hline
$Z(9,30)$  & 45 & 63 & 63 & 0 \\
$Z(14, 29)$ & 61 & 85 & 85 & 0 \\
$Z(20, 20)$ & 58 & 87 & 89 & 0 \\
$Z(20, 37)$ & 78 & 129 & 129 & 0 \\
$Z(30, 30)$ & 88 & 149 & 150 & 0 \\
$Z(40, 40)$ & 119 & 222 & 220 & 0 \\
\hline
Él \% & 57.69\% & 92.63\% & 92.53\% & 92.63\%\\
\hline
Diff & 0 0 0 & 61 44 38 & 53 49 38 & TODO! \\
\hline
Futásidő & 1058s & 1755s & 1824s & TODO! \\
Iteráció & 8000 & 8000 & 6000 & 8000 \\
\hline
\end{tabular}
\end{table}

\subsection*{3. Moser-Tardos javítása}

\textbf{Algoritmus:} Végig megyünk az éleken, és minden élt az LLL-ből kiszámolt valószínűséggel behúzunk, közben számon tartjuk a keletkezett $C_4$-eket. Ezután végigmegyünk minden $C_4$-en és újrasorsoljuk az összes élét. Ezt addig ismételgetjük, amíg van $C_4$. (Triviális javítás a mohó algoritmus használata a folyamat vége után.)

\textbf{Motiváció:} A Moser-Tardos módszer jól ráillik a problémára és az újrasorsolások által pont $C_4$-eket javítja ki, és ahol a gráf már $C_4$-mentes, azt kevésbé változtatja meg. Ezért ez a célzott javítgatás jobb eredményekre ad reményt.

\textbf{Eredmények:}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Z(n, m)} & \textbf{MT C4 + mohó} & \textbf{MT C4 + LLL + Mohó} \\
\hline
$Z(9,30)$  & 63 & 72 \\
$Z(14, 29)$ & 85 & 85 \\
$Z(20, 20)$ & 87 & 97 \\
$Z(20, 37)$ & 130 & 130 \\
$Z(30, 30)$ & 150 & 150 \\
$Z(40, 40)$ & 222 & 221 \\
\hline
Él \% & 92.81\% & 92.83\% \\
\hline
Diff & 72 40 32 & 68 40 38 \\
\hline
Futásidő & 1828s & 1769s \\
Iteráció & 13000 & 15000 \\
\hline
\end{tabular}
\end{table}
\subsection*{4. Moser-Tardos további javítása}

\textbf{Algoritmus:} Ugyanaz, mint a javított verziónál, csak számon tartjuk, hogy melyik él hány különböző $C_4$-ben szerepel, és azt az élt töröljük, ami a legtöbb $C_4$-ben szerepel, majd ezt a törlést iteráljuk, amíg van $C_4$.

\textbf{Motiváció:} A fenti javított változatban igazából az újrasorsolás miatt lehet, hogy egy $C_4$ összes élét kitöröljük, mikor lehet, hogy csak 1 élt kéne kitörölni ahhoz, hogy a gráf $C_4$-mentes legyen. Ez a javítás ezt a problémát megoldja, és mivel mindig a leggyakoribb élt töröljük, ezért ezt a törlést nem kell olyan sokszor megcsinálni. Továbbá valószínűleg a gráf sűrűbb részéről törlünk ki éleket.

\textbf{Eredmények:}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
\hline
\textbf{Z(n, m)} & \textbf{MT C4 IMPROVED} \\
\hline
$Z(9,30)$  & 63 \\
$Z(14, 29)$ & 85 \\
$Z(20, 20)$ & 87 \\
$Z(20, 37)$ & 130 \\
$Z(30, 30)$ & 152 \\
$Z(40, 40)$ & 223 \\
\hline
Él \% & 92.92\% \\
\hline
Diff & 64 45 30 \\
\hline
Futásidő & 1739s \\
Iteráció & 11000 \\
\hline
\end{tabular}
\end{table}

\subsection*{5. Több iteráció futtatása}
\textbf{Algoritmus:}

\begin{algorithm}[H]
\begin{algorithmic}[1]
    \State ...
    \For{belső iterációszám}
        \State véletlenszerű élek beszúrása $p$ valószínűséggel
        \While{van benne $K_{2,2}$}
            \State távolítsuk el azt az $\text{élt}$, amit a legtöbb $K_{2,2}$ tartalmaz
        \EndWhile
    \EndFor
    \State ...
\end{algorithmic}
\end{algorithm}

\textbf{Motiváció:} A legtöbb $C_4$-ben szereplő élek eltávolítására épülő változat célja, hogy kevesebb él törlésével szüntesse meg a $C_4$-eket, miközben megőrzi a gráf kiegyensúlyozott szerkezetét. Ha a gráf egy része már eleve kiegyensúlyozott, akkor az új élek hozzáadása nem, vagy csak minimálisan ront a szerkezeten. Ezzel szemben, ha egy részgráf erősen aszimmetrikus, akkor az új élek beszúrása és a későbbi célzott törlések javíthatják annak struktúráját. Így a folyamat végeredményeként a teljes gráf kiegyensúlyozottabbá válik, ami nagyobb élhalmazt, azaz több megtartható élt eredményezhet.

\textbf{Eredmények (!!Lehetne egybe a felette lévővel!!):}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
\hline
\textbf{Z(n, m)} & \textbf{MT C4.jav + iter} \\
\hline
$Z(9,30)$  & 62 \\
$Z(14, 29)$ & 84 \\
$Z(20, 20)$ & 87 \\
$Z(20, 37)$ & 130 \\
$Z(30, 30)$ & 151 \\
$Z(40, 40)$ & 224 \\
\hline
Él \% & 92.96\% \\
\hline
Diff & 36 60 37 \\
\hline
Futásidő & 1846s \\
Iteráció & 120 \\
Belső Iteráció & 20 \\
\hline
\end{tabular}
\end{table}

\subsection*{7. Dinamikusan karbantartott valószínűségek}
\textbf{Algoritmus:} Kísérletezés után a legjobb alsó korlátokat az alábbi módszer adta, a valószínűségek számítása az alábbi
képlet alapján történt:
\begin{algorithm}[H]
\caption{élbehúzási valószínűségek kódrészlet}
\begin{minted}{c++} 
    int expected_m = ((double)upper_bound / m+0.5); // m osztályú csúcs várható értéke
    int expected_n = ((double)upper_bound / n+0.5); // n osztályú csúcs várható értéke
    double expected_n_percent = (double)upper_bound / (n * m);
    
    double get_multiplier(int v_m){
        if(degree_m[v_m] >= expected_m){
            if(degree_m[v_m] == expected_m)
                return 0.9;
            return 0.5;
        }
        return 6.7 - 5.6 * ((double)degree_m[v_m] / expected_m);
    }

    double get_p(int v_m, int v_n){
        int n = degree_n[v_n];
        return min(get_multiplier(v_m) * (expected_n_percent * 1.1
               - (n/expected_n) * expected_n_percent), 0.8);
    }
\end{minted}    
\end{algorithm}
\textbf{Motiváció:} A következő fejlesztés az élbehúzási valószínűségek futás közbeni módosítása volt. A cél az volt, hogy a csúcsosztályok fokszámai a Roman-féle felső becslés várható értékei felé konvergáljanak. Mivel a Roman-féle felső becslés is egy olyan kiegyensúlyozott gráfot vesz alapul, ahol a kisebbik csúcsosztályban két csúcs fokszámának eltérése legfeljebb egy lehet.

\textbf{Eredmények:}
Megjegyzés: Látni lehet, hogy több iteráció futtatása igazán a dinamikusan karbantartott módszerrel kombinálva hatékony, a lenti eredmények is ezt támasztják alá.
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Z(n, m)} & \textbf{Dinamikus} & \textbf{Dinamikus + iter} \\
\hline
$Z(9,30)$  & 63 & 63 \\
$Z(14, 29)$ & 86 & 86 \\
$Z(20, 20)$ & 88 & 93 \\
$Z(20, 37)$ & 131 & 132 \\
$Z(30, 30)$ & 153 & 153 \\
$Z(40, 40)$ & 223 & 225 \\
\hline
Él \% & 93.35\% & 94.54\% \\
\hline
Diff & 87 38 37 & 133 33 40 \\
\hline
Futásidő & 1724s & 1867s \\
Iteráció & 5300 & 1000 \\
Belső Iteráció & - & 20 \\
\hline
\end{tabular}
\end{table}

\subsection*{7. További Dinamikus valószínúségi módszerek}

\textbf{1. Csak a nagyobb csúcsosztály fokszámainak figyelembevétele:} A Roman becslés is csak a nagyobbik osztály fokszámait használja, a kisebbik osztály fokszámai nincsenek figyelembe véve.\\
\textbf{2. Valószínűségek fixálása minden iterációnál:} Iterációk előtt a valószínűségek fixálása úgy, hogy a behúzott élek várható száma a felső becslés adott százaléka legyen. Így például, ha a felső becslés 100\%-ára állítjuk be a várható értéket, akkor törlések előtt a gráf élszámának várható értéke minden iteráció után a felső becslés lesz, aminél több élt úgysem húzhatnánk be a gráfba.

\textbf{Eredmények:}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Z(n, m)} & \textbf{Alap módszer} & \textbf{Mohó javítással} \\
\hline
$Z(9,30)$  & 75 & 75 \\
$Z(14, 29)$ & 85 & 85 \\
$Z(20, 20)$ & 90 & 90 \\
$Z(20, 37)$ & 116 & 116 \\
$Z(30, 30)$ & 150 & 150 \\
$Z(40, 40)$ & 200 & 200 \\
\hline
Él \% & 50\% & 50\% \\
\hline
\end{tabular}
\end{table}

\subsection*{8. Már megtalált gráfok felhasználása bemenetként}
\textbf{Algoritmus:} Mielőtt elkezdenénk futtatni az algoritmusunkat Z(m,n)-re keressük meg az eddigi legjobb Z(m-1,n) vagy Z(m,n-1) értéket és olvassuk be a hozzá tartozó gráfot. (A program tesztelésénél ötször Z(m-1,n), ötször Z(m,n-1) adja a kiinduló gráfot, ezek felválltva vannak futtatva). Miután megvan a kiinduló gráf az újonnan hozzávett $m'$ csúcsból kimenő éleket véletlen sorrendben megpróbáljuk hozzávenni a gráfhoz. Ehhez először végigmegyünk véletlen sorrendben az érintetlen $N$ csúcsosztály csúcsain, és ha az eddig kiválasztott $N'$ csúcsoknak nincs közös szomszédja az éppen vizsgált $n' \in N$ csúccsal, akkor kiválasztjuk, ellenkező esetben nem.  Így kapunk egy $N'$ csúcshalmazt az érintetlen $N$ csúcsosztályból, ezt a folyamatot $\tfrac{|N|*|M|}{2}+5$-ször megismételjük, majd ezután a legnagyobb elemszámú csúcshalmaz lesz összekötve az újonnan hozzávett csúccsal. Látható, hogy az így kapott kiinduló gráf továbbra is $C_4$ mentes marad, hiszen $N'$-ben minden $n_i$, $n_j$ csúcspárnak pontosan egy közös szomszédja van, a most hozzávett $m'$ csúcs.

\textbf{Motiváció:} Magától értetődő, hogy ha már van egy jó gráf, amit valahogyan újra tudunk használni a futás közben, akkor nem éri meg nulláról indulni, hiszen a már meglévő gráf felépítése is időt vesz el, így ez többé kevésbé megspórolható. A másik, megalapozottabb érv egy csúcs hozzáadására a következő:

\begin{quote}
Ha $G = (A, B, E)$ egy $K_{2,2}$-mentes, $(m,n)$ méretű páros gráf, és $\delta(A)$ az $A$ osztályban vett minimális fokszám, akkor
\[
Z(m-1, n) \geq |E(G)| - \delta(A),
\]
\[
Z(m, n-1) \geq |E(G)| - \delta(B).
\]
\end{quote}
Az állítás magától értetődő, ami viszont meglepő lehet, hogy sok esetben a bemutatott becslés használata elég a felső korlát eléréséhez. Ezt jól szemlélteti, hogy a $Z(13, 18)$-tól egészen $Z(3, 3)$-ig el lehet jutni ezzel az egy becsléssel, úgy hogy közben csak pontos értéken haladsz át. "Nem teljesen igaz meg kell csinálni rendesen, az elvétellel kapott gráf adja az inputot"

\subsection*{9. Öt eddigi legjobb gráf felhasználása bemenetként}
\textbf{Algoritmus:} Ugyanaz, mint az előző algoritmus, csak minden iterációban az eddigi legjobb öt kiinduló gráfot olvasunk be, és mindegyikből lefuttatjuk az algoritmust. Továbbá ebben a változatban nem csak a legjobb, hanem az öt legjobb gráfot mentjük el.

\textbf{Motiváció:} Mi történik, hogyha $Z(m,n)$ és $Z(m,n+1)$ struktúrája lényegesen eltérő. Az eredeti kiegészítős módszerrel, ekkor hiába találjuk $(m,n)$-re az optimális gráfot a $(m,n+1)$-hez használt kiinduló gráfon nagyon sok módosítást kéne végeznünk, nem is biztos, hogy jól járunk a kiinduló gráfunkkal. Öt, élszámra már $Z(m,n)$-hez egészen közel lévő, strukturájukban különböző gráf használatával sokkal nagyobb az esélyünk, hogy megtaláljuk az ilyen eseteket.

\subsection*{Végső táblázat, értékelés}

A módszer már egy órányi futtatás után is közel kerül a jelenleg ismert felső korlátokhoz(majd felette mindenhol pontos iterációszám és paraméterek). A végső eredményeket a \textbf{top 5-ös módszer} többszöri, hosszú futtatása adta, továbbá ennek egy kicsit módosított változata, mivel nem minden gráf struktúrája ugyanolyan.A minimum és maximum fokszám az optimumban bizonyos esetekben nagyon távol lehet egymástól. A Roman becslés, és a bemutatott és használt dinamikus valószínűségi logika is a teljesen egyenletes fokszámeloszlást veszi alapul, ezért azoknak az eseteknek a megtalálása kevésbé valószínű a fenti módszerrel.
Emiatt egy kicsit módosított valószínűségi logikával futó kód jobb eredményeket produkált, azokban az esetekben, ahol a gráf optimális fokszámai erősen aszimmetrikusak.

\textbf{Módosított logika:} Minden élhez futtatás előtt random eltérítési értéket generálunk, amely pozitív vagy negatív irányba módosítja az élbehúzási valószínűséget. Ez növeli az esélyt az aszimmetrikus, de optimális struktúrák megtalálására.


\vspace{1cm}\vfill
Budapest, \today
\begin{flushright}
\begin{minipage}{0.5\textwidth}
\begin{center}
	dr. Katona Gyula\\
	\textit{egyetemi docens}\\
	\textit{tanszékvezető}
\end{center}
\end{minipage}
\end{flushright}
\vfill
\end{document}