\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{t1enc}
\usepackage[magyar]{babel}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{minted} 
 \geometry{ a4paper, textwidth=180mm, textheight=257mm, left=15mm, top=20mm, bottom=25mm}
\usepackage{fancyhdr}
\pagestyle{fancy}

\chead{\includegraphics[height=15mm]{bme_logo_kicsi}}
\setlength{\headsep}{50pt}
\geometry{bottom=30mm}
\fancyfoot[C]{\footnotesize\sl
\begin{tabular}{r|l} 
Budapesti Műszaki és Gazdaságtudományi Egyetem & 1117 Budapest, Magyar tudósok körútja 2. I.B.132.\\
Villamosmérnöki és Informatikai Kar & Telefon: 463-2585, Fax: 463-3157\\
Számítástudományi és Információelméleti Tanszék & http:\textbackslash\textbackslash www.cs.bme.hu\\
\end{tabular}}
\renewcommand{\headrulewidth}{0.4pt}\renewcommand{\footrulewidth}{0.4pt}

\begin{document} \ \
\vspace{2mm}
\begin{center}
{\Large\sc
Önálló Labor\\[5mm]
\bf 
Random konstrukciók programozása a Zarankiewicz problémához
\\[10mm]
{\Large
Borsik Balázs
}\\[10mm]
Témavezető: Dr.Héger Tamás
}
\end{center}
\vspace{1cm}

\section*{1. Alapfogalmak}
\textbf{Páros gráf:} (Szükséges-e? – Nem biztos.)\\[2mm]
\textbf{Zarankiewicz-szám:} Egy $G = (A,B;E)$ páros gráf $K_{s,t}$-mentes, ha nem tartalmaz olyan $s$ csúcsot $A$-ban és $t$ csúcsot $B$-ben, amelyek egy $K_{s,t}$-vel izomorf részgráfot alkotnak. Az $(m,n)$ méretű $K_{s,t}$-mentes páros gráf éleinek maximális számát $Z_{s,t}(m,n)$-nel jelöljük, és Zarankiewicz-számnak nevezzük.\\[2mm]
\textbf{Zarankiewicz-probléma (eredeti megfogalmazás):} Vegyünk egy $n \times m$-es mátrixot, amely csak 0 és 1 értékeket tartalmaz. Legkevesebb hány darab 1-es szükséges, hogy mindenképp tartalmazzon $s \times t$-es csupa 1-es részmátrixot? Ez a definíció megegyezik $Z_{s,t}(m,n) + 1$-gyel.
\section*{2. Bemutatás}
Mint látható, a Zarankiewicz probléma egy extremális gráfelméleti probléma. A problémára több képlet is ad értelmezhető felső becsléseket, de ezek a becslések általában a paraméterek nagyságának vagy aszimmetriájának növelésével jelentősen eltérhetnek a pontos értékektől.\\

Alsó becslésekre kevesebb képlet található; ezekben az esetekben különféle konstrukciók (pl. projektív síkok, affin síkok), vagy kimerítő keresések adhatnak jobb közelítő értéket.\\

Az önálló labor célja a random konstrukciókkal kapott alsó becslések vizsgálata és programozása volt.

\section*{3. Felső becslések bemutatása}
A felső becslésekhez alkalmazható például a \textbf{Jensen-egyenlőtlenség}, amely az alábbi módon fogalmazható meg:

\[
\phi\left( \frac{1}{n} \sum_{i=1}^{n} x_i \right) \leq \frac{1}{n} \sum_{i=1}^{n} \phi(x_i),
\]

ha $\phi$ konvex függvény. Ez az egyenlőtlenség segít az egyes Zarankiewicz-számokra adott becslések levezetésében.
\\[2mm]
A projekt során is használt felső becslés pedig \textbf{Roman becslése} volt, ami a Jensen-egyenlőtlenségből kapott paraméterezett változatt, így sokkal kényelmesebben használható. A program során ez a becslés adta az élvalószínűségek alapját.
\\[2mm]
\textbf{Roman-egyenlőtlenség:} Legyen $I \subset \mathbb{R}$ egy intervallum, $f : I \to \mathbb{R}$ egy szigorúan növekvő konvex vagy szigorúan csökkenő konkáv függvény, $n \in \mathbb{N}$, $x_1, \dots, x_n, p, p+1 \in I \cap \mathbb{Z}$. Ekkor
\[
\sum_{i=1}^{n} x_i \leq \frac{\sum_{i=1}^{n} f(x_i)}{f(p+1) - f(p)} + n \cdot \frac{p f(p+1) - (p+1) f(p)}{f(p+1) - f(p)}.
\]
\\[2mm]
Az egyenlőség pontosan akkor áll fenn, ha $x_i \in \{p, p+1\}$ minden $1 \leq i \leq n$ esetén, vagy ha $\{x_1, \dots, x_n, p, p+1\} \subset I'$ egy olyan intervallumban, amelyen $f$ lineáris.
\\[2mm]
\textbf{Roman-féle felső korlát:} Legyen $G = (A, B; E)$ egy $K_{s,t}$-mentes páros gráf, ahol $|A| = m$, $|B| = n$, és $p \geq s - 1$. Ekkor $G$ éleinek számára teljesül:
\[
e(G) \leq \frac{t - 1}{\binom{p}{s - 1}} \binom{m}{s} + n \cdot \frac{(p + 1)(s - 1)}{s}.
\]

\section*{4. Programozás, módszerek}

\textbf{Program alapja:} A program minden változata \texttt{C++} nyelven készült. A gráfokat szomszédossági mátrixban tároljuk, mivel a vizsgált intervallumban a használt algoritmusokkal ez a módszer gyorsabbnak bizonyult az éllistás tárolásnál.


\subsection*{C\textsubscript{4}-ek algoritmusai}

\begin{itemize}
    \item \textbf{Triviális módszer:} Véletlenszerű sorrendben húzunk be éleket. Ha egy él behúzása $C_4$-et hozna létre, akkor azt az élt nem húzzuk be.
    
    \item \textbf{Első irány – Moser–Tardos módszer:} 
    
    \textbf{Tétel (LLL egy változata):} Legyenek $E_1, \dots, E_n$ események egy valószínűségi térben, $G$ legyen egy függetlenségi gráf, $d \geq 1$, és teljesüljön:
    \begin{itemize}
        \item $\mathbb{P}(E_i) \leq p$ minden $i$-re,
        \item $G$-ben a csúcsok foka legfeljebb $d$,
        \item $4dp \leq 1$.
    \end{itemize}
    Ekkor $\mathbb{P}\left( \bigcap_{i=1}^n \overline{E_i} \right) > 0$.
    \\[2mm]
    \textbf{Moser-Tardos algoritmus:}
    \begin{enumerate}
        \item Kiértékeljük a $\xi \in \mathcal{P}$ változókat egy véletlen $\omega \in \Omega$ helyen. Ha egyik $E_i$ sem következik be, akkor $\omega$ egy elemi esemény a $\bigcap_{i=1}^n \overline{E_i}$ metszetből, és az eljárás véget ér.
        \item Ha valamelyik $E_j$ bekövetkezett, akkor újra kiértékeljük a $P_j$-beli $\xi$ változókat a saját eloszlásuk szerint, függetlenül. A $P \setminus P_j$ változókat változatlanul hagyjuk. Ezután ismét ellenőrizzük, hogy bekövetkezik-e valamelyik $E_i$, és szükség esetén ismételjük a 2. lépést.
    \end{enumerate}

    \textit{Megjegyzés:} Moser és Tardos bizonyították, hogy a 2. lépést várhatóan legfeljebb $\frac{n}{d-1}$ alkalommal kell elvégezni.

    \textbf{Programváltozatok:}
    \begin{enumerate}
        \item $E_i$ esemény: Egy csúcsosztályban két csúcsnak van két közös szomszédja.
        \item $E_i$ esemény: $C_4$ képződik.
    \end{enumerate}

    A $p$ (élbehúzási valószínűség) értéke kezdetben az LLL alapján lett megválasztva. Később, mivel $p$ növelése jobb eredményeket adott hasonló futásidő mellett, ezért a prezentált eredményekben:
    \begin{itemize}
        \item Az 1. esetben $p$ a Roman-féle felső becslés szerinti várható érték 80\%-a.
        \item A 2. esetben 85\%-a.
    \end{itemize}
\end{itemize}

\begin{algorithm}[H]
\caption{Moser Tardos pszeudokódja}
\begin{algorithmic}[1]

\Function{\textproc{BecsültMaxÉlek}}{$m$, $n$, $\text{iterációk}$}
    \State $\text{maxélek} \gets 0$
    \State $\text{élek} \gets$ minden lehetséges él $m$ és $n$ között
    \State $p \gets$ felső becslés alapján számolt valószínűség

    \For{$i = 1$ \textbf{tól} $\text{iterációk}$}
        \State gráf inicializálása üres $m \times n$ mátrixként
        \State véletlenszerű élek beszúrása $p$ valószínűséggel

        \While{van benne $K_{2,2}$}
            \State távolítsuk el azt az $\text{élt}$, amit a legtöbb $K_{2,2}$ tartalmaz
        \EndWhile

        \State véletlenszerűen keverjük az éleket

        \For{minden él}
            \If{nem hoz létre $K_{2,2}$-t}
                \State adjuk hozzá a gráfhoz
            \EndIf
        \EndFor

        \If{aktuális gráf él száma $>$ $\text{maxélek}$}
            \State $\text{maxélek} \gets$ új érték
        \EndIf
    \EndFor

    \State \Return $\text{maxélek}$
\EndFunction

\end{algorithmic}
\end{algorithm}


\subsection*{Második irány – Dinamikusan karbantartott valószínűségek}

A következő fejlesztés az élbehúzási valószínűségek futás közbeni módosítása volt. A cél az volt, hogy a csúcsosztályok fokszámai a Roman-féle felső becslés várható értékei felé konvergáljanak. Kísérletezés után a legjobb alsó korlátokat az alábbi módszer adta, a valószínűségek számítása az alábbi képlet alapján történt:

\begin{algorithm}[H]
\caption{élbehúzási valószínűségek kódrészlet}
\begin{minted}{c++} 
    int expected_m = ((double)upper_bound / m+0.5); // m osztályú csúcs várható értéke
    int expected_n = ((double)upper_bound / n+0.5); // n osztályú csúcs várható értéke
    double expected_n_percent = (double)upper_bound / (n * m);
    
    double get_multiplier(int v_m){
        if(degree_m[v_m] >= expected_m){
            if(degree_m[v_m] == expected_m)
                return 0.9;
            return 0.5;
        }
        return 6.7 - 5.6 * ((double)degree_m[v_m] / expected_m);
    }

    double get_p(int v_m, int v_n){
        int n = degree_n[v_n];
        return min(get_multiplier(v_m) * (expected_n_percent * 1.1
               - (n/expected_n) * expected_n_percent), 0.8);
    }
\end{minted}    
\end{algorithm}

\textbf{További két módszer:}
\begin{enumerate}
    \item Csak a nagyobb csúcsosztály fokszámainak figyelembevétele.
    \item Iterációk előtt a valószínűségek fixálása úgy, hogy a behúzott élek várható száma a felső becslés adott százaléka legyen.
\end{enumerate}

\subsection*{Harmadik fejlesztés – Több iteráció futtatása}
\begin{algorithm}
\begin{algorithmic}[1]
    \State ...
    \For{belső iterációszám}
        \State véletlenszerű élek beszúrása $p$ valószínűséggel
        \While{van benne $K_{2,2}$}
            \State távolítsuk el azt az $\text{élt}$, amit a legtöbb $K_{2,2}$ tartalmaz
        \EndWhile
    \EndFor
    \State ...
\end{algorithmic}
\end{algorithm}


Több belső iteráció futtatása egy programfutás alatt javította az alsó becsléseket.

\subsection*{Negyedik irány – Korábban talált gráfok újrafelhasználása}

\textbf{Ötlet:} Amikor $Z(n,m)$-et számolunk, induljunk a korábban megtalált $Z(n-1, m)$ gráfból. Adjunk hozzá egy új csúcsot az $n$ csúcsosztályhoz, majd próbáljunk minél több élt behúzni ebből a csúcsból a másik osztályba anélkül, hogy $C_4$-et hoznánk létre.

\textbf{Két változat:}
\begin{enumerate}
    \item A fenti módszer közvetlen megvalósítása.
    \item A legjobb 5 gráf mentése és újraindítása a fenti stratégiával.
\end{enumerate}

\subsection*{Végső táblázat, értékelés}

A módszer már egy órányi futtatás után is közel kerül a jelenleg ismert felső korlátokhoz(majd felette mindenhol pontos iterációszám és paraméterek). A végső eredményeket a \textbf{top 5-ös módszer} többszöri, hosszú futtatása adta, továbbá ennek egy kicsit módosított változata, mivel nem minden gráf struktúrája ugyanolyan.A minimum és maximum fokszám az optimumban bizonyos esetekben nagyon távol lehet egymástól. A Roman becslés, és a bemutatott és használt dinamikus valószínűségi logika is a teljesen egyenletes fokszámeloszlást veszi alapul, ezért azoknak az eseteknek a megtalálása kevésbé valószínű a fenti módszerrel.
Emiatt egy kicsit módosított valószínűségi logikával futó kód jobb eredményeket produkált, azokban az esetekben, ahol a gráf optimális fokszámai erősen aszimmetrikusak.

\textbf{Módosított logika:} Minden élhez futtatás előtt random eltérítési értéket generálunk, amely pozitív vagy negatív irányba módosítja az élbehúzási valószínűséget. Ez növeli az esélyt az aszimmetrikus, de optimális struktúrák megtalálására.

\section*{Fogalmak}

\begin{itemize}
    \item $K_{n,m}$: Egy $(N,M,E)$ teljes páros gráf, ahol $|N|=n$, $|M|=m$ és bármely $u \in N$ és $v \in M$ között van él behúzva.
    \item $C_4$: $K_{2,2}$
    \item Egy gráf \textbf{triviálisan kiegészíthető}, ha létezik olyan még nem behúzott él, melynek behúzása után nem keletkezik $C_4$.
\end{itemize}

\section*{Programváltozatok}

\subsection*{1. Mohó algoritmus}
\textbf{Algoritmus:} Módszer random sorrendben végig megyünk az összes élen, ha egy él behúzása $C_4$-et hozna létre, akkor nem húzzuk be, különben behúzzuk. (Így a gráf biztos, hogy triviálisan nem kiegészíthető, hiszen, ha az lenne, akkor a behúzható élt már behúztuk volna, amikor az algoritmus során vizsgáljuk.)

\textbf{Motiváció:} Az éleket csak sorban vizsgálva a gráf nagyon aszimmetrikus lenne, például az elsőnek vizsgált csúcs össze lenne kötve az egész másik csúcsosztállyal, és mivel a felső becslések is minél egyenletesebb fokszámeloszlást vesznek alapul, a projektív síkok, és abból képzett konstrukciók is ilyenek, ezért az élek random sorrendje lehetővé teszi egy átlagosan sokkal kiegyensúlyozottabb gráf előállítását, miközben a gráf továbbra is triviálisan nem kiegészíthető marad.

\textbf{Eredmények:}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Z(n, m)} & \textbf{Alap módszer} & \textbf{Mohó javítással} \\
\hline
$Z(9,30)$  & 75 & 75 \\
$Z(14, 29)$ & 85 & 85 \\
$Z(20, 20)$ & 90 & 90 \\
$Z(20, 37)$ & 116 & 116 \\
$Z(30, 30)$ & 150 & 150 \\
$Z(40, 40)$ & 200 & 200 \\
\hline
Él \% & 50\% & 50\% \\
\hline
\end{tabular}
\end{table}

\subsection*{2. Moser-Tardos}

\textbf{Algoritmus:} Végig megyünk az éleken, és minden élt az LLL-ből kiszámolt valószínűséggel behúzunk, közben számon tartjuk a kisebbik/nagyobbik (még nem eldöntött, meg kell nézni mindkettőt!) csúcsosztályban az összes csúcspár közös szomszédjainak számát. Ha egy $(u,v)$ él behúzásra kerül, akkor az összes olyan $(u,u')$ csúcspár közös szomszédjainak számát növeljük eggyel, ahol $u'$ szomszédos $v$-vel. Ezután végigmegyünk minden csúcspáron, és ha a közös szomszédaik száma $\geq 2$, akkor újrasorsoljuk a csúcspár összes élét. Ezt addig ismételgetjük, amíg van olyan csúcspár, ahol a közös szomszédok száma $\geq 2$. (Triviális javítás a mohó algoritmus használata a folyamat vége után, ennek eredményeiről lentebb.)

\textbf{Motiváció:} A Moser-Tardos módszer jól ráillik a problémára és az újrasorsolások által pont két csúcs közös szomszédjait javítja ki, és ahol a gráf már $C_4$-mentes, azt kevésbé változtatja meg. Ezért ez a célzott javítgatás jobb eredményekre ad reményt.

\textbf{Eredmények:}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Z(n, m)} & \textbf{Alap módszer} & \textbf{Mohó javítással} \\
\hline
$Z(9,30)$  & 75 & 75 \\
$Z(14, 29)$ & 85 & 85 \\
$Z(20, 20)$ & 90 & 90 \\
$Z(20, 37)$ & 116 & 116 \\
$Z(30, 30)$ & 150 & 150 \\
$Z(40, 40)$ & 200 & 200 \\
\hline
Él \% & 50\% & 50\% \\
\hline
\end{tabular}
\end{table}

\subsection*{3. Moser-Tardos javítása}

\textbf{Algoritmus:} Végig megyünk az éleken, és minden élt az LLL-ből kiszámolt valószínűséggel behúzunk, közben számon tartjuk a keletkezett $C_4$-eket. Ezután végigmegyünk minden $C_4$-en és újrasorsoljuk az összes élét. Ezt addig ismételgetjük, amíg van $C_4$. (Triviális javítás a mohó algoritmus használata a folyamat vége után.)

\textbf{Motiváció:} A Moser-Tardos módszer jól ráillik a problémára és az újrasorsolások által pont $C_4$-eket javítja ki, és ahol a gráf már $C_4$-mentes, azt kevésbé változtatja meg. Ezért ez a célzott javítgatás jobb eredményekre ad reményt.

\textbf{Eredmények:}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Z(n, m)} & \textbf{Alap módszer} & \textbf{Mohó javítással} \\
\hline
$Z(9,30)$  & 75 & 75 \\
$Z(14, 29)$ & 85 & 85 \\
$Z(20, 20)$ & 90 & 90 \\
$Z(20, 37)$ & 116 & 116 \\
$Z(30, 30)$ & 150 & 150 \\
$Z(40, 40)$ & 200 & 200 \\
\hline
Él \% & 50\% & 50\% \\
\hline
\end{tabular}
\end{table}
\subsection*{4. Moser-Tardos további javítása}

\textbf{Algoritmus:} Ugyanaz, mint a javított verziónál, csak számon tartjuk, hogy melyik él hány különböző $C_4$-ben szerepel, és azt az élt töröljük, ami a legtöbb $C_4$-ben szerepel, majd ezt a törlést iteráljuk, amíg van $C_4$.

\textbf{Motiváció:} A fenti javított változatban igazából az újrasorsolás miatt lehet, hogy egy $C_4$ összes élét kitöröljük, mikor lehet, hogy csak 1 élt kéne kitörölni ahhoz, hogy a gráf $C_4$-mentes legyen. Ez a javítás ezt a problémát megoldja, és mivel mindig a leggyakoribb élt töröljük, ezért ezt a törlést nem kell olyan sokszor megcsinálni. Továbbá valószínűleg a gráf sűrűbb részéről törlünk ki éleket.

\textbf{Eredmények:}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Z(n, m)} & \textbf{Alap módszer} & \textbf{Mohó javítással} \\
\hline
$Z(9,30)$  & 75 & 75 \\
$Z(14, 29)$ & 85 & 85 \\
$Z(20, 20)$ & 90 & 90 \\
$Z(20, 37)$ & 116 & 116 \\
$Z(30, 30)$ & 150 & 150 \\
$Z(40, 40)$ & 200 & 200 \\
\hline
Él \% & 50\% & 50\% \\
\hline
\end{tabular}
\end{table}

\subsection*{5. Eredmények Moser-Tardos módszerekkel megnövelt valószínűséggel egy táblázatban:}

\textbf{Eredmények:} 

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
\textbf{Z(n,m)} & \textbf{Mohó} & \textbf{MT - mohó} & \textbf{MT} & \textbf{MT + jav.} & \textbf{MT + C4 jav.} & \textbf{MT + C4 jav. törlés} \\
\hline
$Z(20,20)$ & 90 & 90 & 90 & 90 & 90 & 90 \\
$Z(30,30)$ & 150 & 150 & 150 & 150 & 150 & 150 \\
$Z(40,40)$ & 200 & 200 & 200 & 200 & 200 & 200 \\
$Z(14,29)$ & 85 & 85 & 85 & 85 & 85 & 85 \\
$Z(9,30)$  & 75 & 75 & 75 & 75 & 75 & 75 \\
$Z(20,37)$ & 116 & 116 & 116 & 116 & 116 & 116 \\
\hline
Él \% & 50\% & 50\% & 50\% & 50\% & 50\% & 50\% \\
\hline
\end{tabular}
\caption{Különböző algoritmusok $Z(n,m)$ értékeinek összehasonlítása}
\end{table}


\vspace{1cm}\vfill
Budapest, \today
\begin{flushright}
\begin{minipage}{0.5\textwidth}
\begin{center}
	dr. Katona Gyula\\
	\textit{egyetemi docens}\\
	\textit{tanszékvezető}
\end{center}
\end{minipage}
\end{flushright}
\vfill
\end{document}
